// 静态库和动态库理论对比
// 使用库的好处,提高程序的编译速度,
// 静态库
//  固定的,以静态文件的方式
// 动态库(共享库)
//  动态库加载和使用麻烦一些
// 区别
//	静态:有多少个文件用这个库,就生成多少个库,如:一个库是10M,一共10个文件要用最后大小是大于100M的大小,他会把静态库所有的函数全加载上,每个程序大小是10M+当前文件大小
//	动态:把动态库加载内存中,让用这个库的文件一起用,内存只占动态库的大小,只要源文件中要用到库中函数,调用就行了,程序的大小是源文件的大小
//	定眼一看动态>静态,还有源代码加载速度,静态库和源代码里面的函数一样快,但动态库一定会比静态库慢
//	静态库应用:对空间要求较低,而时间要求较高的核心程序中,比方计算机操作系统的历程,就是rom内存
//	动态库应用:对时间要求较低,对空间要求较高
// 静态库用的比较少,如数据库:MySQL
// 动态库用的比较多
// 
//动态库的制作
// 就是一系列功能相近相结合的,编译是最耗时的
// ar rcs libmylib.a file1.o	要用到ar 参数是rcs lib名字.a(起名要求必须以lib开头,如果是静态库的话以.a结尾) 原材料是file1.o(就是拿那些东西做出来的)
//		编译成.o文件gcc -c sub.c -o sub.o
//		然后在做库ar rcs libmymath.a *.o
// 静态库制作步骤
//	1.将.c生成.o文件:gcc -c add.c -o add.o
//	2.使用ar工具制作静态库:ar rcs libxxx.a add.o(必须是.c在前,.o在后)
//	3.使用静态库:和源文件一起进行编译就行了gcc text1.c libmymath.a -o text1.o
// 隐式声明是:函数在使用之前,编译器要么碰到函数定义要么函数声明,如果都没有,编译器帮你做隐式声明,最会做一种声明,返回值是int 调用函数名(调用的参数类型) 解决办法就是普通的函数声明,但一般是.h中引用.所以声明放到.h中,实现在.cpp中
// 头文件要加ifndef xxx	defind xxx	.....	endif 防止重复定义
//	因为库和头文件还有源文件不可能放到一个文件夹中所以,一个完整的静态库调用是:gcc text1.c ./lib/libmymath.a -o test1.o -I ./inc.
//动态库制作以及使用(和上面差不多,但优点小差别)
// 1.将.c生成.o文件.(生成与位置无关的代码 -fPIC)地址要固定(不然找不到),还记得连接的时候要做的事情吗(数据段合并,地址回填)
//	地址回填的意思打比方:最后生成a.out可执行程序的时候a.out的地址是以main为依据的,然后main函数内的地址都是以main为依据+多少的地址(也就是汇编中的offset,是ip偏移地址).在生成.o的时候main函数的地址是0.然后经过连接生成.out的是时候他的main函数有地址了然后main函数内的函数就会有地址了(类似于绝对地址(cs:ip)和相对地址( ip))
//	如果要制作动态库呢,动态库中的函数就不是以main为依据了,动态库的函数的地址是加载他到内存然后调用才有地址.看了反汇编发现动态库比静态库调用多了一个@plt,什么时候@plt将会被填充呢,将动态库加载到内存得到内存地址就行了
//	延迟绑定:就是要在做一次@plt填充,相当于plt是一个段地址，需要等到动态库加载到内存中才能确定.
//	结论是制作动态库的时候我们用到的.o文件与跟静态库有差别,要生成与位置无关的代码 -fPIC
// 1.1制作 gcc -c add.c -o add.o -fPIC (要加-fPIC才支持制作动态库)
// 2.使用gcc -shared 来制作动态库:gcc -shared -o lib库命.so add.o
// 3.编译可执行程序时,指定所使用的动态库. -l(库命) -L(库路径)中间不加空格:gcc test.c -o test.o -lmymath -L./lib
// 4.运行可执行程序 ./a.out 出错了!!!(LSB=小端存储)
//	原因:(他们两个没有关系)
//		链接器: 工作与链接阶段(可执行文件生成前) 工作需要-l和-L支持
//		动态链接器: 程序运行阶段,工作时需要提供动态库所在目录位置.(但是都是那几个固定的位置去找)
//	报错是在动态链接器,在固定的地方放入动态库就行了,这个地方是一个环境变量:LD_LIBRARY_PATH=./lib 但是 你还没导出,所以前面加个export.总体命令是:export LD_LIBRARY_PATH=动态库路径
//	最后./xxx.out成功!!! 但环境变量是进程的概念,只要这个进程重启,环境变量也跟着变换,所以要改配置文件vim ~/.bashrc 然后在后加export LD_LIBRARY_PATH=动态库绝对路径
//	提示c的标准库是动态库,他的位置是动态链接器找的位置,我们可以滥竽充数
//	配置文件法也可以在 vim /etc/ld.so.conf 加上动态库的绝对路径,然后ldconfig -v生效
//	使用ldd xxx.out 来检查程序
//数据段合并说一下
// 先说一下linux32位内存,32位大小一共4G,但64位的比例是一样的没区别
//	0-3G是用户,3-4G是内核,以后就开始学习内核的知识了
//		用户空间有 .text(代码段) .rodata(只读数据区) .data(数据区) .bss()[data和bss的区别是一个未初始化的一个初始化非0的] .heap堆 .so加载位置(动态库) .stack栈 .环境变量main函数参数
//		数据段合并:.text(代码段)和.rodata(只读数据区)都不可任意更改是or然后合并,好处是节省空间(因为内存的最低大小4k也是最大内存对齐的大小),然后.data(数据区)和.bss()都是可读写的所以是rw合并.但是0-3G不单单就这些段,大概有30个段.所以要合并
// 
